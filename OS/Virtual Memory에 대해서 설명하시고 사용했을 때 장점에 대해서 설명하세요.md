# Virtual Memory에 대해서 설명하시고 사용했을 때 장점에 대해서 설명하세요

## 면접용 답변

가상메모리란 물리적 메모리의 한계를 초과하는 메모리 요구를 처리하기 위해 운영 체제가 사용하는 기술입니다. 실제로는 물리적 메모리와 디스크 기반의 스왑 공간을 조합하여 사용합니다. 이는 메모리의 효율적 사용과 프로그램 간 격리, 메모리 보호를 가능하게 하는 장점이 있습니다. 또한 각 프로세스가 독립된 메모리 공간을 가지기 때문에, 프로세스 간 메모리 충돌을 방지합니다.

# 개념 정리

## 가상메모리란?

- 실제 물리적 메모리(RAM)의 크기에 관계없이, 프로그램이 사용할 수 있는 메모리 공간을 확장하는 기술
- 운영체제가 하드디스크의 일부 공간을 **가상 메모리**로 활용하여, 물리 메모리가 부족할 때에도 프로그램이 계속 실행될 수 있도록함
    - 가상 주소 공간: 프로세스마다 독립적인 메모리 주소 공간을 제공함
        - 여러 프로세스가 동시에 실행되어도 서로 간의 메모리 충돌을 방지할 수 있음
    - 메모리 보호: 가상 메모리를 통해 한 프로세스가 다른 프로세스의 메모리에 접근하지 못하게 보호할 수 있음

### → 가상 메모리의 동작 원리는 크게 페이징과 세그멘테이션 두 가지 방식으로 나누어짐

## 페이징

- 일반적으로 사용되는 방식
- 가상 메모리와 물리적 메모리를 페이지라는 작은 고정 크기의 블록으로 나누는 방식
- **페이지**: 가상 메모리의 일정 크기 단위 (보통 4KB 또는 8KB)로 나눈 블록
- **프레임(Frame)**: 물리 메모리의 일정 크기 단위로 나눈 블록
    - 페이지와 크기가 동일함
- **페이지 테이블(Page Table)**: 각 프로세스의 가상 주소와 실제 물리 주소를 매핑하는 테이블

### 페이징 시스템의 동작 과정

1. **가상 주소 -> 물리 주소 변환**: 프로그램이 데이터를 읽거나 쓸 때 가상 주소를 참조함
    - CPU는 가상 주소를 물리 주소로 변환해야 하며, 이를 위해 페이지 테이블을 참조함
2. **페이지 부재(Page Fault)**: 프로그램이 접근하려는 페이지가 현재 물리 메모리에 없으면 **페이지 부재**가 발생함
    - 운영체제는 하드디스크에서 해당 페이지를 물리 메모리로 로드함
3. **교체 정책**: 물리 메모리가 꽉 찼을 때는, 새로운 페이지를 불러오기 위해 기존의 페이지 중 하나를 내보내야 함.
    
    →  이를 **페이지 교체 알고리즘**으로 결정함 
    
    - 페이지 교체 알고리즘 예시:  **LRU(Least Recently Used)**, **FIFO(First In, First Out)**

## 세그멘테이션

- 가상 메모리를 논리적으로 크기가 다른 **세그먼트**로 나누는 방식
- 프로그램은 코드, 데이터, 스택 등의 메모리 공간을 각각 다른 세그먼트로 구분하여 관리함
- 장점: 논리적인 구분이 명확함
- 단점: 페이징만큼 효율적이지 않음

## 가상 메모리의 장점

1. 물리적 메모리보다 확장된 메모리 공간: 물리적 메모리 크기에 구애받지 않고, 더 큰 메모리 공간을 제공할 수 있음
    
    → 대규모 프로그램을 실행하거나 많은 데이터 처리에 유리함
    
2. 프로그램 실행 중단 방지
    - 프로그램이 실행 중에 물리적 메모리가 부족한 상황이 발생하더라도, 가상 메모리를 통해 필요한 데이터를 디스크에서 가져와 계속 실행할 수 있음
        - 시스템 성능 저하를 최소화
3. 메모리 보호 및 프로세스 격리
    - 각 프로세스에 독립적인 가상 메모리 공간을 할당하여, 한 프로세스가 다른 프로세스의 메모리 영역을 침범하지 못하게함
4. 메모리 효율성 향상
    - 프로그램이 실제로 사용하는 메모리만 물리적 메모리에 적재
        
        → 물리 메모리의 효율적인 사용이 가능함
        
5. 페이지 교체 알고리즘을 통한 성능 최적화
    - 물리메모리가 꽉 찼을 때도 페이지 교체 알고리즘을 통해 최적의 성능을 유지할 수 있음

## 2단계 페이징

- 가상 메모리 공간이 매우 클 경우, 하나의 페이지 테이블이 너무 커져서 메모리에 올려두기 어려운 문제가 발생함
    
    **→ 2단계 페이징: 페이지 테이블 자체를 계층 구조로 나눈것**
    
- 처리 흐름
    - CPU는 가상 주소를 참조함
    - 상위 페이지 번호로 페이지 디렉터리에서 하위 페이지 테이블의 주소를 찾음
    - 하위 페이지 번호로 해당 페이지 테이블에서 물리 프레임 번호를 찾음
    - 오프셋을 통해 최종 물리 주소 결정
- 장점: 큰 주소 공간에서도 효율적으로 페이지 테이블 관리 가능
- 단점: 접근 시 메모리 참조 횟수 증가함 → 성능 저하 가능성

## 스왑 공간 관리

- Swap 공간: 디스크에 마련된 가상 메모리 저장 공간
- 개념: 물리 메모리가 부족할 때, 사용하지 않는 페이지를 디스크로 내보내고(Swap out), 필요할 때 다시 불러오는(Swap in) 방식으로 메모리를 관리
- Swap이 과도하게 발생하면 시스템 전체 성능이 급격히 저하됨 → Thrashing 현상

## 대표적인 페이지 교체 알고리즘

- LRU (Least Recently Used): 가장 오래 사용하지 않은 페이지 제거
- FIFO (First In First Out): 가장 먼저 들어온 페이지 제거

# 추가 질문

## 페이징과 세그멘테이션의 차이는?

- 페이징: 메모리를 고정 크기 블록(페이지)로 나누어 관리함
    - 장점: 외부 단편화가 줄어듦
    - 단점: 내부 단편화는 발생
- 세그멘테이션은 논리적인 단위(코드, 스택, 데이터 등)로 나누어 관리함
    - 장점: 논리적인 구분이 명확함
    - 단점:외부 단편화는 발생

## 가상 메모리를 사용하지 않으면 생길 수 있는 문제는?

- 물리 메모리 크기 내에서만 실행이 가능하므로, 메모리가 부족한 경우, 실행 자체가 어려울 수 있음
- 각 프로세스의 메모리 공간이 격리되지 않기 때문에, 한 프로세스가 다른 프로세스의 메모리를 침범할 수 있어 보안상 위험이 있음