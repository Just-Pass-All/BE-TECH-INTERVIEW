# 문맥교환(Context Switching)이란 무엇인가요?

## 면접용 답변

문맥 교환은 운영체제가 하나의 프로세스나 스레드의 실행 상태를 저장하고, 다른 프로세스나 스레드를 실행하기 위해 이전 상태를 복원하는 과정입니다.
CPU가 여러 작업을 번갈아가며 수행할 수 있도록 하는 핵심 메커니즘이며, 이 과정에서 PCB(Process Control Block)나 스레드 컨텍스트 정보가 저장되고 복원됩니다.

컨텍스트 스위칭은 멀티태스킹과 병렬 처리에 필수적이지만, 빈번하게 발생하면 오버헤드가 생겨 전체 시스템 성능을 저하시킬 수 있습니다.

<br>

## 개념 설명

### 문맥 교환(Context Switching)이란?

- 현재 실행 중인 **프로세스나 스레드의 상태(문맥)를 저장**하고  
- 다른 프로세스/스레드의 상태를 **복원**하여 실행 흐름을 전환하는 것  
- 주로 타이머 인터럽트, 입출력 대기, 우선순위에 따른 스케줄링 등에서 발생

---

### 문맥(Context) 구성 정보

문맥(Context)은 CPU가 어떤 프로세스를 실행 중인지 나타내는 **실행 상태의 전체 정보**이며,  
이 중 일부는 **PCB**에 저장되고, 일부는 **다른 구조에서 관리되거나 참조됨**.

### PCB(Process Control Block)

| 항목             | 설명                                   |
|------------------|--------------------------------------|
| **프로세스 상태**    | Running, Ready, Blocked 등 현재 상태      |
| **프로그램 카운터** | 다음에 실행할 명령어의 메모리 주소                  |
| **CPU 레지스터**   | 레지스터 값 전체 (일반 레지스터, Stack Pointer 등) |
| **메모리 맵 정보**  | 힙, 스택, 코드 영역의 주소 정보 (실제 내용 X)        |
| **스케줄링 정보**  | 우선순위, 스케줄링 큐 위치, CPU 사용 시간 등         |
| **프로세스 식별자** | PID, 부모 PID, 사용자 ID 등                |
| **I/O 정보**      | 열린 파일, 입출력 버퍼, 디바이스 정보 등             |


### PCB 외부에서 관리되는 기타 문맥 정보

| 항목               | 관리 위치 / 설명                                                              |
|--------------------|-------------------------------------------------------------------------|
| **힙/스택의 데이터 값**   | 힙/스택/데이터의 실제 값은 메모리에 존재 (PCB에는 주소만)                                     |
| **스레드 제어 정보 (TCB)** | 멀티스레드 시스템에서는 각 스레드의 레지스터, 상태 등은 TCB에 저장<br>(하나의 프로세스 내 스레드는 공통의 PCB 공유) |
| **캐시, TLB 상태**     | CPU 내부에 존재하며 문맥 교환 시 초기화되거나 무효화되어 성능에 영향을 줌                             |

---

### 문맥 교환(Context Switching) 과정 순서

1. **인터럽트 발생**  
   - 타이머 인터럽트, 입출력 완료 등으로 현재 실행 중인 프로세스 중단

2. **현재 프로세스의 문맥 저장**  
   - 운영체제가 현재 프로세스의 레지스터, 프로그램 카운터 값을 **PCB에 저장**

3. **스케줄러 호출**  
   - 어떤 프로세스를 다음에 실행할지 결정 (스케줄링 알고리즘에 따라 선택)

4. **선택된 프로세스의 문맥 복원**  
   - 운영체제가 PCB에서 문맥 정보를 읽어와 **CPU에 로드**

5. **프로세스 실행 재개**  
   - 문맥이 복원된 프로세스가 CPU에서 이어서 실행


### 문맥 교환이 발생하는 주요 상황

| 상황                           | 설명                                                |
|--------------------------------|---------------------------------------------------|
| **타이머 인터럽트**                 | CPU 점유 시간이 끝나면 현재 프로세스를 중단하고 다른 프로세스로 교체          |
| **입출력 대기**                    | 현재 프로세스가 I/O를 기다리는 동안 CPU를 다른 프로세스에 할당            |
| **우선순위 스케줄링에 의한 선점**       | 더 높은 우선순위의 프로세스가 등장하면 현재 프로세스를 선점하여 문맥 교환 발생      |
| **멀티프로세스 환경에서 전환**        | 독립된 프로세스 간 전환으로, 주소 공간까지 완전히 바뀌며 가장 큰 오버헤드 발생     |
| **멀티스레드 환경에서 스레드 전환**   | 하나의 프로세스 내 여러 스레드 간 전환. 주소 공간이 공유되어 프로세스 전환보다 가벼움 |

---

### 문맥 교환의 단점: 오버헤드

- 문맥 저장 및 복원 자체가 비용이 드는 작업
- 캐시 미스, TLB 플러시 등의 부수적 성능 저하도 발생  
  → 서로 다른 프로세스로 전환되면 주소 공간이 바뀌어, 기존 캐시·TLB 정보가 무효화되기 때문
- 빈번한 컨텍스트 스위칭은 CPU 사용률 저하로 이어질 수 있음  
  → 작업 처리보다 전환 관리에 CPU 자원이 소모되기 때문

---

### 문맥 교환 줄이기 전략

> 문맥 교환의 **빈도를 줄이고**, 발생 시 **오버헤드를 최소화**하는 것이 핵심

| 전략                   | 설명 |
|------------------------|------|
| **CPU 바인딩**            | 스레드를 특정 코어에 고정해 캐시/TLB 재사용률 향상 |
| **스레드 풀 사용**         | 스레드를 매번 생성하지 않고 재사용해 전환 빈도 감소 |
| **락 최소화**             | 경쟁 조건 줄여 불필요한 스레드 전환 방지 |
| **비동기 처리**           | I/O 대기 중에도 다른 작업 수행 → 스레드 전환 줄임 |
| **코루틴 활용**           | 스레드 대신 사용자 수준 전환으로 오버헤드 최소화 |

---

## 추가 질문

### 문맥 교환의 오버헤드는 어떤 방식으로 줄일 수 있나요?
문맥 교환의 빈도와 비용을 줄이는 것이 중요합니다.  
이를 위해 스레드를 미리 만들어 재사용하는 스레드 풀, I/O 작업 중에도 스레드 전환 없이 실행이 가능한 비동기 처리,
그리고 락 경쟁을 줄이기 위한 락 최소화와 CPU 바인딩 같은 전략을 사용할 수 있습니다.  
또한 코루틴이나 사용자 수준 스레드를 활용하면 커널 개입 없이 전환이 가능해 오버헤드를 더욱 줄일 수 있습니다.


### 프로세스와 스레드 간 문맥 교환의 차이를 설명해주세요.
프로세스 간 문맥 교환은 주소 공간 전체를 바꿔야 하기 때문에 오버헤드가 큽니다.
레지스터뿐 아니라 메모리 맵, 페이지 테이블 등도 변경되므로 TLB 플러시, 캐시 무효화가 발생합니다.

반면, 스레드 간 문맥 교환은 동일한 프로세스 내에서 발생하므로 주소 공간을 공유하며, 변경되는 정보가 적습니다.
레지스터, 스택 포인터만 바꾸면 되기 때문에 훨씬 가볍고 빠릅니다.

### 병렬 처리를 위해 시스템을 설계한다면, 어떤 조건에서 프로세스를, 어떤 조건에서 스레드를 선택하시나요?
프로세스는 독립된 메모리 공간을 갖기 때문에, 안정성과 격리성이 중요한 경우에 적합합니다.
예를 들어, 서로 영향을 주면 안 되는 마이크로서비스 구조나 보안이 중요한 애플리케이션은 프로세스 기반으로 설계합니다.

반면, 스레드는 메모리 공간을 공유하므로 가볍고 전환이 빠르며, 데이터 공유가 쉬워 높은 성능이 요구되는 시스템에 적합합니다.
같은 작업을 병렬로 처리하거나 실시간성이 중요한 서버 애플리케이션에서는 스레드가 더 적합합니다.