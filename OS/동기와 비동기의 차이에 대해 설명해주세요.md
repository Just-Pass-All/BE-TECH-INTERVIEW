# 동기와 비동기의 차이에 대해 설명해주세요

## 면접용 답변 
동기와 비동기의 차이는 작업 완료를 기다리는지 여부에 있습니다.
<br> 동기 방식은 요청한 작업이 끝날 때까지 기다렸다가 다음 작업을 수행합니다.
<br> 반면 비동기 방식은 요청 후 작업이 끝나기를 기다리지 않고 바로 다음 작업을 수행합니다.


## 개념 설명

### 동기
- 작업이 순차적으로 진행되는 것
- 호출한 함수 또는 작업이 반환될 때까지 대기하는 동안 "실행흐름이 차단"되는 특징 있음 

장점 : 간단하고 직관적인 코드
단점 : 여러 작업이 동시에 실행되는 경우, 전체 프로세스의 성능이 저하죌 수 있음 

### 비동기
- 작업이 독립적으로 실행되는 것.
- 작업의 완료 여부를 기다리지 않고 다른 작업을 실행할 수 있는 방식
- 주로 I/O 작업이나 네트워크 요청처럼 시간이 오래 걸리는 작업에 유용함. 
- 콜백, 프라미스, async/await등의 메커니즘을 통해 구현 가능 


#### 1. 콜백
- 비동기 작업이 끝났을 때 호출되는 함수를 인자로 전달하는 방식 
- 작업 요청 -> 요청과 함께 콜백 함수 등록 -> 작업 완료 -> 콜백함수 실행

```javascript
function getData(callback) {
  setTimeout(() => {
    callback("📦 Data received!");
  }, 1000); // 1초 후 실행
}

getData(function(result) {
  console.log(result); // → "📦 Data received!"
});

```
<br>

#### 2. 프로미스
- 미래에 값이 채워질 수도 있는 객체
- 비동기 작업의 `성공/실패 상태와 결과`를 표현
- 상태
  - pending → fulfilled/rejected로 전이
- 사용 방식
  - `then()`으로 성공 시 콜백 연결
    `catch()`로 에러 처리

```javascript
function getData() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve("📦 Data with Promise");
    }, 1000);
  });
}

getData()
  .then(result => console.log(result))
  .catch(error => console.error(error));

```

<br>


#### 3.  async / await
- Promise를 기반으로 비동기 작업을 마치 동기처럼 작성할 수 있게 도와주는 문법
- async 함수는 항상 Promise를 반환 
- await는 Promise가 처리될 때까지 기다렸다가 다음 줄 실행
```javascript
async function fetchData() {
  try {
    const result = await getData(); // getData는 Promise 반환
    console.log(result); // → "📦 Data with Promise"
  } catch (e) {
    console.error(e);
  }
}

```

<br>


### 동기 VS 비동기
- 작업 흐름 구조의 차이

| 구분 | 동기(Synchronous)       | 비동기(Asynchronous)          |
| -- | --------------------- | -------------------------- |
| 정의 | **작업이 끝날 때까지 기다림**    | **작업 완료를 기다리지 않음**         |
| 흐름 | 직선적, 순차적              | 병렬적, 이벤트 기반                |
| 특징 | 다음 작업은 현재 작업이 끝나야 실행됨 | 다음 작업은 즉시 실행됨 (결과는 나중에 받음) |
| 예시 | 함수 호출이 끝난 후 다음 코드 실행  | 요청만 하고, 완료되면 콜백/이벤트로 처리    |
| 장점 | 흐름이 단순, 예측 쉬움         | 효율적, 대기시간 최소화 가능           |
| 단점 | 대기 시간 동안 자원 낭비        | 흐름 파악이 어려움, 복잡도 증가         |

### 블로킹 vs 논블로킹
- 자원 점유 여부의 차이

| 구분 | 블로킹(Blocking)               | 논블로킹(Non-blocking)        |
| -- | --------------------------- | ------------------------- |
| 정의 | 작업 완료까지 대기                  | 바로 반환, 완료는 나중에 처리         |
| 관계 | 블로킹 = 주로 동기 방식              | 논블로킹 = 주로 비동기 방식          |
| 예시 | `read()` 호출 시, 데이터 올 때까지 멈춤 | `read()` 요청하고 바로 다음 코드 실행 |


### 예시
카페에서 커피를 주문 하는 상황 

✅ 동기
<br> 주문하고 음료가 나올 때까지 카운터 앞에서 기다림 


✅ 비동기
<br> 주문하고 음료 나올 때까지 자리에 앉아서 일하다가, 음료가 나오면 가지러 감


✅ 블로킹
<br> 점원이 한명만 있어서, 4개의 음료를 만들 동안 다른 손님 주문 못 받음 


✅ 논블로킹
<br> 한 점원이 주문을 받고,  음료 제조는 다른 직원에게 넘기고
<br> 바로 다음 손님 주문 받음 

## 꼬리 질문 

1. 동기 방식이 적합한 상황은 언제인가요?
- 순서와 결과가 중요하고, 처리 흐름이 직관적일 때 
- 예를 들어, 결제 승인 후 주문 생성처럼 앞선 작업이 성공해야 다음 작업이 가능한 경우 동기 방식이 안전하고 신뢰성이 높습니다.

2. 블로킹과 동기의 차이점은 무엇인가요?
- 동기는 작업이 끝날 때까지 다음 작업을 시작하지 않는 방식이고, 블로킹은 작업이 끝날 때까지 현재 스레드가 멈추는 상태를 말합니다. 
- 동기는 흐름 제어의 개념이고, 블로킹은 리소스 대기 상태로 인해 실행이 멈추는 물리적인 현상입니다.